// Generated by gencpp from file pamplemousse_sensors/SpatialState.msg
// DO NOT EDIT!


#ifndef PAMPLEMOUSSE_SENSORS_MESSAGE_SPATIALSTATE_H
#define PAMPLEMOUSSE_SENSORS_MESSAGE_SPATIALSTATE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <pamplemousse_sensors/systemStatus.h>
#include <pamplemousse_sensors/filterStatus.h>

namespace pamplemousse_sensors
{
template <class ContainerAllocator>
struct SpatialState_
{
  typedef SpatialState_<ContainerAllocator> Type;

  SpatialState_()
    : header()
    , system_status()
    , filter_status()
    , unix_time_seconds(0)
    , microseconds(0)
    , latitude(0.0)
    , longitude(0.0)
    , height(0.0)
    , velocity()
    , body_acceleration()
    , g_force(0.0)
    , orientation()
    , angular_velocity()
    , standard_deviation()  {
      velocity.assign(0.0);

      body_acceleration.assign(0.0);

      orientation.assign(0.0);

      angular_velocity.assign(0.0);

      standard_deviation.assign(0.0);
  }
  SpatialState_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , system_status(_alloc)
    , filter_status(_alloc)
    , unix_time_seconds(0)
    , microseconds(0)
    , latitude(0.0)
    , longitude(0.0)
    , height(0.0)
    , velocity()
    , body_acceleration()
    , g_force(0.0)
    , orientation()
    , angular_velocity()
    , standard_deviation()  {
  (void)_alloc;
      velocity.assign(0.0);

      body_acceleration.assign(0.0);

      orientation.assign(0.0);

      angular_velocity.assign(0.0);

      standard_deviation.assign(0.0);
  }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef  ::pamplemousse_sensors::systemStatus_<ContainerAllocator>  _system_status_type;
  _system_status_type system_status;

   typedef  ::pamplemousse_sensors::filterStatus_<ContainerAllocator>  _filter_status_type;
  _filter_status_type filter_status;

   typedef uint32_t _unix_time_seconds_type;
  _unix_time_seconds_type unix_time_seconds;

   typedef uint32_t _microseconds_type;
  _microseconds_type microseconds;

   typedef double _latitude_type;
  _latitude_type latitude;

   typedef double _longitude_type;
  _longitude_type longitude;

   typedef double _height_type;
  _height_type height;

   typedef boost::array<float, 3>  _velocity_type;
  _velocity_type velocity;

   typedef boost::array<float, 3>  _body_acceleration_type;
  _body_acceleration_type body_acceleration;

   typedef float _g_force_type;
  _g_force_type g_force;

   typedef boost::array<float, 3>  _orientation_type;
  _orientation_type orientation;

   typedef boost::array<float, 3>  _angular_velocity_type;
  _angular_velocity_type angular_velocity;

   typedef boost::array<float, 3>  _standard_deviation_type;
  _standard_deviation_type standard_deviation;





  typedef boost::shared_ptr< ::pamplemousse_sensors::SpatialState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::pamplemousse_sensors::SpatialState_<ContainerAllocator> const> ConstPtr;

}; // struct SpatialState_

typedef ::pamplemousse_sensors::SpatialState_<std::allocator<void> > SpatialState;

typedef boost::shared_ptr< ::pamplemousse_sensors::SpatialState > SpatialStatePtr;
typedef boost::shared_ptr< ::pamplemousse_sensors::SpatialState const> SpatialStateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::pamplemousse_sensors::SpatialState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::pamplemousse_sensors::SpatialState_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::pamplemousse_sensors::SpatialState_<ContainerAllocator1> & lhs, const ::pamplemousse_sensors::SpatialState_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.system_status == rhs.system_status &&
    lhs.filter_status == rhs.filter_status &&
    lhs.unix_time_seconds == rhs.unix_time_seconds &&
    lhs.microseconds == rhs.microseconds &&
    lhs.latitude == rhs.latitude &&
    lhs.longitude == rhs.longitude &&
    lhs.height == rhs.height &&
    lhs.velocity == rhs.velocity &&
    lhs.body_acceleration == rhs.body_acceleration &&
    lhs.g_force == rhs.g_force &&
    lhs.orientation == rhs.orientation &&
    lhs.angular_velocity == rhs.angular_velocity &&
    lhs.standard_deviation == rhs.standard_deviation;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::pamplemousse_sensors::SpatialState_<ContainerAllocator1> & lhs, const ::pamplemousse_sensors::SpatialState_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace pamplemousse_sensors

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::pamplemousse_sensors::SpatialState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::pamplemousse_sensors::SpatialState_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::pamplemousse_sensors::SpatialState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::pamplemousse_sensors::SpatialState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::pamplemousse_sensors::SpatialState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::pamplemousse_sensors::SpatialState_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::pamplemousse_sensors::SpatialState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "9da90427e4173bf5bfbba0285b9b9e2e";
  }

  static const char* value(const ::pamplemousse_sensors::SpatialState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x9da90427e4173bf5ULL;
  static const uint64_t static_value2 = 0xbfbba0285b9b9e2eULL;
};

template<class ContainerAllocator>
struct DataType< ::pamplemousse_sensors::SpatialState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "pamplemousse_sensors/SpatialState";
  }

  static const char* value(const ::pamplemousse_sensors::SpatialState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::pamplemousse_sensors::SpatialState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# SpatialState.msg\n"
"# This is a message to hold the System State Packet from the Advanced Navigation Spatial INS\n"
"#\n"
"# System State Packet\n"
"# Packet ID: 20\n"
"# Length: 100 bytes\n"
"#\n"
"Header header\n"
"\n"
"systemStatus system_status\n"
"filterStatus filter_status\n"
"uint32 unix_time_seconds\n"
"uint32 microseconds\n"
"float64 latitude                # [rad]\n"
"float64 longitude               # [rad]\n"
"float64 height                  # [m]\n"
"float32[3] velocity             # [m/s]\n"
"float32[3] body_acceleration    # [m/s/s]\n"
"float32 g_force                 # [g]\n"
"float32[3] orientation          # [rad]\n"
"float32[3] angular_velocity     # [rad/s]\n"
"float32[3] standard_deviation   # [m]\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
"\n"
"================================================================================\n"
"MSG: pamplemousse_sensors/systemStatus\n"
"# Defines the System Status subfields for the Spatial INS System State messages\n"
"#\n"
"uint8 system_failure\n"
"uint8 accelerometer_sensor_failure\n"
"uint8 gyroscope_sensor_failure\n"
"uint8 magnetometer_sensor_failure\n"
"uint8 pressure_sensor_failure\n"
"uint8 gnss_failure\n"
"uint8 accelerometer_over_range\n"
"uint8 gyroscope_over_range\n"
"uint8 magnetometer_over_range\n"
"uint8 pressure_over_range\n"
"uint8 minimum_temperature_alarm\n"
"uint8 maximum_temperature_alarm\n"
"uint8 low_voltage_alarm\n"
"uint8 high_voltage_alarm\n"
"uint8 gnss_antenna_disconnected\n"
"uint8 serial_port_overflow_alarm\n"
"================================================================================\n"
"MSG: pamplemousse_sensors/filterStatus\n"
"# Defines the Filter Status subfields for the Spatial INS System State messagesuint8 orientation_filter_initialised\n"
"#\n"
"uint8 ins_filter_initialised\n"
"uint8 heading_initialised\n"
"uint8 utc_time_initialised\n"
"uint8 gnss_fix_type\n"
"uint8 event1_flag\n"
"uint8 event2_flag\n"
"uint8 internal_gnss_enabled\n"
"uint8 magnetic_heading_enabled\n"
"uint8 velocity_heading_enabled\n"
"uint8 atmospheric_altitude_enabled\n"
"uint8 external_position_active\n"
"uint8 external_velocity_active\n"
"uint8 external_heading_active\n"
;
  }

  static const char* value(const ::pamplemousse_sensors::SpatialState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::pamplemousse_sensors::SpatialState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.system_status);
      stream.next(m.filter_status);
      stream.next(m.unix_time_seconds);
      stream.next(m.microseconds);
      stream.next(m.latitude);
      stream.next(m.longitude);
      stream.next(m.height);
      stream.next(m.velocity);
      stream.next(m.body_acceleration);
      stream.next(m.g_force);
      stream.next(m.orientation);
      stream.next(m.angular_velocity);
      stream.next(m.standard_deviation);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct SpatialState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::pamplemousse_sensors::SpatialState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::pamplemousse_sensors::SpatialState_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "system_status: ";
    s << std::endl;
    Printer< ::pamplemousse_sensors::systemStatus_<ContainerAllocator> >::stream(s, indent + "  ", v.system_status);
    s << indent << "filter_status: ";
    s << std::endl;
    Printer< ::pamplemousse_sensors::filterStatus_<ContainerAllocator> >::stream(s, indent + "  ", v.filter_status);
    s << indent << "unix_time_seconds: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.unix_time_seconds);
    s << indent << "microseconds: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.microseconds);
    s << indent << "latitude: ";
    Printer<double>::stream(s, indent + "  ", v.latitude);
    s << indent << "longitude: ";
    Printer<double>::stream(s, indent + "  ", v.longitude);
    s << indent << "height: ";
    Printer<double>::stream(s, indent + "  ", v.height);
    s << indent << "velocity[]" << std::endl;
    for (size_t i = 0; i < v.velocity.size(); ++i)
    {
      s << indent << "  velocity[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.velocity[i]);
    }
    s << indent << "body_acceleration[]" << std::endl;
    for (size_t i = 0; i < v.body_acceleration.size(); ++i)
    {
      s << indent << "  body_acceleration[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.body_acceleration[i]);
    }
    s << indent << "g_force: ";
    Printer<float>::stream(s, indent + "  ", v.g_force);
    s << indent << "orientation[]" << std::endl;
    for (size_t i = 0; i < v.orientation.size(); ++i)
    {
      s << indent << "  orientation[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.orientation[i]);
    }
    s << indent << "angular_velocity[]" << std::endl;
    for (size_t i = 0; i < v.angular_velocity.size(); ++i)
    {
      s << indent << "  angular_velocity[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.angular_velocity[i]);
    }
    s << indent << "standard_deviation[]" << std::endl;
    for (size_t i = 0; i < v.standard_deviation.size(); ++i)
    {
      s << indent << "  standard_deviation[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.standard_deviation[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // PAMPLEMOUSSE_SENSORS_MESSAGE_SPATIALSTATE_H
